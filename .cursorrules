// 언어 설정
Always respond in Korean. // 모든 응답은 한국어로 출력되도록 설정

// 타입 및 컴포넌트 구조
Use TypeScript for all components. // 모든 컴포넌트는 TypeScript 기반
Use React functional components with hooks. // React는 함수형 컴포넌트와 훅을 사용
Use absolute imports from the `src` folder. // 상대 경로 대신 절대 경로 import 사용
Use camelCase for variable and function names. // 변수, 함수 이름은 camelCase
Use PascalCase for component names. // 컴포넌트 이름은 PascalCase
Do not use `any` type unless absolutely necessary. // TypeScript의 any는 가능한 사용하지 않음
All components should be typed explicitly with props interfaces. // props는 interface/type으로 명시적으로 타입 지정

// 3D 및 셰이더
Use React Three Fiber and Drei for all 3D rendering. // Three.js는 R3F + Drei로 구성
GLSL shaders must be written in separate .glsl files and imported using ?raw. // 셰이더는 .glsl 파일로 작성 후 ?raw로 import
Use ShaderMaterial with proper uniforms and attributes. // ShaderMaterial에 uniform/attribute 명확히 정의
All 3D components should be modular and reusable. // 3D 컴포넌트는 모듈화 및 재사용 가능하게 작성

// 코드 스타일 & 유틸
Always include JSDoc-style comments for exported functions. // export된 함수에 JSDoc 주석 사용
Avoid inline styles and use SCSS modules. // inline 스타일 금지, SCSS 모듈 사용
Prefer destructuring in function arguments. // 함수 인자는 구조분해 할당 선호
Group related utility functions in a utils folder. // 유틸 함수는 /utils 폴더에 정리
Each component should be in its own folder with an index.tsx entry. // 컴포넌트는 폴더 단위로 분리하고 index.tsx로 진입

// 애니메이션
Use GSAP for all animations instead of CSS transitions or keyframes. // 애니메이션은 전부 GSAP 사용
Use `will-change` in SCSS for elements that will be animated to optimize rendering performance. // 애니메이션 대상 요소에 will-change 지정하여 성능 최적화
Use GSAP and ScrollTrigger for all scroll-based animations instead of native scroll listeners. // 스크롤 관련 애니메이션은 ScrollTrigger 사용

// 상태 관리
Use Zustand with Immer for all client-side state management. // 클라이언트 상태는 Zustand + Immer로 관리
Each Zustand store should be modularized by domain in the `/store` folder. // 상태 파일은 도메인 단위로 `/store`에 정리
Use SWR or React Query for all server-side data fetching. // 서버 데이터 fetch는 SWR 또는 React Query 사용

// 폴더 구조 및 파일 구조 유지
Use a domain-based folder structure for maintainability. // 유지보수성을 고려해 도메인 기반 폴더 구조 구성
Organize shaders in a separate `/shaders` folder and import with `?raw`. // 셰이더는 `/shaders` 폴더에 저장
Use index.ts exports in each folder for easier imports and cleaner paths. // 각 폴더에 index.ts 내보내기 사용하여 쉬운 가져오기 및 더 깨끗한 경로 유지
Co-locate tests and styles with their components. // 테스트와 스타일은 컴포넌트와 같은 폴더에 위치

// 프로젝트 설정
// yarn Berry + Monorepo 설정
//yarn berry - pnp 기본 사용이지만 vite, storybook이 pnp와 충돌 가능성이 있어 nodeLinker: node-modules 방식으로 전환
Use Yarn Berry as the package manager with Plug'n'Play (PnP) disabled via nodeLinker: node-modules.
Organize the project as a Yarn Workspaces monorepo. // 프로젝트를 Yarn Workspaces 모노레포로 구성
Use one workspace per domain or concern (e.g., `app`, `lib`, `ui`, `design`). // 도메인 또는 관심사별로 하나의 워크스페이스 사용
Always run yarn install at the root to maintain consistent workspace resolution. // 루트에서 yarn install을 항상 실행하여 일관된 워크스페이스 해결 유지
Never use npm install or pnpm install within the workspace. // 워크스페이스 내에서 npm install 또는 pnpm install 사용 금지
Do not commit .yarn/cache or .yarn/unplugged unless caching is required for CI. //.yarn/cache 또는 .yarn/unplugged 캐시는 보통 gitignore 처리 but CI에서 사용시 커밋
Always commit .yarnrc.yml, .gitignore, and yarn.lock to version control. // 프로젝트의 의존성 정확성 유지를 위해 lockfile과 yarn 설정은 필수 커밋 대상
Use .yarnrc.yml to fix registry and nodeLinker settings. // 같은 환경을 유지하도록 npm registry 고정 및 nodeLinker 설정 필요

//Vite + Storybook
Use Vite as the default build tool and dev server. // Vite를 기본 빌드 도구로 사용
Configure Storybook to use the Vite builder (@storybook/builder-vite). // Storybook에서 Vite 빌더 사용
Document components inside the lib or ui workspace with .stories.tsx files. // 공통 컴포넌트들은 .stories.tsx 파일로 문서화 → 스토리북에서 시각적 테스트 가능
Use Storybook as the source of truth for UI components and visual tests. // Storybook을 단순한 UI 프리뷰 툴이 아닌, 컴포넌트의 기준(reference)으로 사용
Group stories by component in the same folder using co-location. // 스토리북 스토리는 컴포넌트 폴더 내에 위치

//형식 검사 & 코드 정리
Use a shared ESLint and Prettier configuration across all workspaces. // 모든 워크스페이스에서 공유 ESLint 및 Prettier 설정 사용
Run type checking, linting, and formatting checks in pre-commit and CI. // 프리커밋 및 CI에서 타입 검사, 린팅, 포맷팅 실행
